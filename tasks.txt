1- LinkedIn article about variables allocation in stack and heap for both value and ref types 

لما تيجي تبرمج ف
 C# أو أي لغة تعتمد على .NET، هتلاقي نفسك بتتعامل مع أنواع بيانات مختلفة: value types (زي الأرقام الصحيحة والـ structs) وreference types (زي الـ classes والـ arrays). بس السؤال المهم: إزاي وأين بيتخزنوا في الـ Stack أو الـ Heap؟ تعالوا نوضح الفرق ببساطة!


الأول: يعني إيه Stack و Heap؟
1. Stack:
هو منطقة في الذاكرة بتنظم البيانات على شكل LIFO (Last In, First Out).
سريع جدًا لأنه منظم وبسيط.
بيستخدم لتخزين value types والمتغيرات المحلية اللي بتعيش لفترة قصيرة (scope معين).
2. Heap:
منطقة في الذاكرة مخصصة لتخزين البيانات اللي بتعيش لفترة طويلة أو مش معروف عمرها أثناء وقت التنفيذ.
أبطأ شوية من الـ Stack لأنه محتاج إدارة أكتر (زي الـ Garbage Collector في .NET).
بيستخدم لتخزين reference types والـ objects اللي حجمها مش ثابت.
الفرق بين Value Types و Reference Types:
Value Types (أنواع القيم):
زي: int, float, bool, struct.
دايمًا بيتم تخزينهم في الـ Stack.
لما تعمل نسخة منهم، بيتم نسخ القيمة بالكامل، يعني كل نسخة مستقلة عن التانية.
Reference Types (أنواع المرجع):
زي: class, array, string.
بيتخزن المرجع (العنوان) بتاعهم في الـ Stack، لكن البيانات نفسها بتتخزن في الـ Heap.
لما تعمل نسخة، النسخة الجديدة بتشير لنفس العنوان (البيانات مشتركة).


ليه الموضوع ده مهم؟
الأداء:

الـ Stack سريع جدًا، فلو بتحتاج كود عالي الأداء ومش معقد، حاول تعتمد على الـ value types أكتر.
الـ Heap مناسب للكائنات الكبيرة والمرنة، لكن لازم تاخد بالك إنه ممكن يعمل ضغط على الـ Garbage Collector.
الإدارة:

البيانات في الـ Stack بتنتهي بمجرد انتهاء الـ scope.
الكائنات في الـ Heap بتفضل موجودة لحد ما الـ Garbage Collector يتدخل.
ملاحظات للمبتدئين:
مش كل حاجة لازم تعرفها من الأول. افهم الأساسيات، ومع الوقت هتعرف إمتى تهتم بالتفاصيل دي.
تجربة العملية أهم من النظرية. جرب بنفسك واستخدم أدوات زي الـ Visual Studio Debugger علشان تشوف البيانات بتتحرك فين.



- what's the difference between compiled and interpreted languages and in this way what 
about Csharp? 



 (Compiled Languages):
إزاي بتشتغل؟

الكود اللي بتكتبه (Source Code) بيتحول بالكامل لـ Machine Code مرة واحدة من خلال برنامج اسمه Compiler.
بعد ما الكود يتجمع، بيطلع ملف تنفيذي (Executable File) زي .exe أو .bin.
المميزات:

أسرع في التنفيذ، لأن الكود مترجم بالكامل وجاهز للتشغيل.
أقل اعتماد على البرنامج اللي كتب الكود (compiler مش محتاج يتواجد وقت التشغيل).
العيوب:

محتاج وقت أطول في مرحلة التجميع.
لو فيه تعديل صغير في الكود، لازم تجمع البرنامج كله من الأول.
أمثلة:

C، C++، Rust.
ا(Interpreted Languages):
إزاي بتشتغل؟

الكود بيتفسر سطر بسطر أثناء التشغيل من خلال برنامج اسمه Interpreter.
الكود مش بيتحول لـ Machine Code بشكل كامل مسبقًا.
المميزات:

أسهل في التعديل والتجربة لأنك مش محتاج تجمع الكود.
مرونة أعلى في تطوير البرامج.
العيوب:

أبطأ في التنفيذ لأنه بيتفسر سطر بسطر.
محتاج وجود الـ Interpreter مع الكود أثناء التشغيل.
أمثلة:

Python، JavaScript، Ruby.


C# بتجمع بين الاتنين، وده اللي بيخليها لغة هجينة (Hybrid):

Compilation (تجميع مبدأي):

الكود اللي بتكتبه في C# بيتحول الأول لـ Intermediate Language (IL) أو أحيانًا بيقولوا عليه Bytecode، وده بيتم من خلال الـ C# Compiler.
Interpretation (تنفيذ أثناء التشغيل):

وقت تشغيل البرنامج، الـ IL بيتفسر لـ Machine Code بواسطة الـ Common Language Runtime (CLR)، وهو جزء من الـ .NET Framework.







 Compare between implicit, explicit, Convert and parse casting 


. Implicit Casting (التحويل الضمني):
إزاي بيشتغل؟

التحويل بيتم تلقائي من غير ما تكتب حاجة إضافية في الكود.
بيشتغل لما التحويل آمن، زي لما تحول من نوع أصغر لنوع أكبر.
مثال:


int myInt = 10;
double myDouble = myInt; // Implicit Casting
Console.WriteLine(myDouble); // Output: 10.0
المميزات:

بسيط وآمن.
مفيش فقدان بيانات.
العيوب:

بيشتغل بس مع الحالات اللي التحويل فيها مضمون وآمن (زي من int لـ double).
2. Explicit Casting (التحويل الصريح):
إزاي بيشتغل؟

لازم تقول للكومبيلر إنك عارف المخاطر وعايز تعمل الكاستنج بنفسك.
بيتستخدم لما التحويل ممكن يكون فيه فقدان بيانات (زي من double لـ int).
مثال:


double myDouble = 10.5;
int myInt = (int)myDouble; // Explicit Casting
Console.WriteLine(myInt); // Output: 10
المميزات:

بيديك سيطرة أكبر على الكاستنج.
العيوب:

ممكن يحصل فقدان بيانات (زي حذف الجزء العشري).
لازم تتأكد إن التحويل آمن وإلا هيحصل خطأ.
Convert (استخدام دالة التحويل):
إزاي بيشتغل؟

بيستخدم الميثودز الموجودة في الكلاس Convert لتحويل القيم بين الأنواع.
بيشتغل مع معظم الأنواع، حتى لو مش فيه علاقة مباشرة.
مثال:


string myString = "123";
int myInt = Convert.ToInt32(myString); // Convert
Console.WriteLine(myInt); // Output: 123
المميزات:

بيشتغل مع أنواع كتير.
بيتعامل مع قيم null بشكل أفضل (بيحولها لـ 0 أو قيمة افتراضية).
العيوب:

لو القيمة مش صالحة للتحويل (زي تحويل كلمة نصية لـ رقم)، هيحصل Exception.
4. Parse (تحليل النصوص):
إزاي بيشتغل؟

بيحول النصوص (Strings) لأنواع رقمية أو أنواع تانية بشرط يكون النص صالح للتحويل.
مثال:


string myString = "123";
int myInt = int.Parse(myString); // Parse
Console.WriteLine(myInt); // Output: 123
المميزات:

سريع ومباشر لما النص صحيح (valid).
العيوب:

لو النص مش صالح للتحويل، هيحصل Exception (زي "abc").
مش بيتعامل مع null بشكل جيد (هيعمل Exception).